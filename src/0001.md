### 组件的本质

我们可以把 `UI 的展现`看成一个`函数的执行过程`。
其中，`Model` 是输入参数，函数的执行结果是 `DOM 树`，也就是 `View`。
而 `React` 要保证的，就是每当 `Model 发生变化时`，函数会重新执行，并且`生成新的 DOM 树`，
然后 `React` 再把新的 DOM 树以最优的方式`更新到浏览器`。


### state的原则

遵循的一个原则就是：`state 中永远不要保存可以通过计算得到的值。`


### 组合和继承

组合让组件交互方式更加简单，只有 props。

而继承则比较复杂，因为存在父方法调用或者覆盖等场景。

函数组件，一定是组合的方式了（因为继承是class的概念或者prototype）


### 单向数据流

意味着数据只有一种方式可以传输到应用程序的其他部分

1. 状态传递给视图和子组件

2. 操作由视图触发

3. 动作可以更新状态

4. 状态更改将传递到视图和子组件

dom树的单向数据流，数据从父节点传递到子节点(通过props)。如果顶层(父级)的某个props改变了，React会重新渲染所有的子节点。


### 生命周期

``` js
shouldComponentUpdate(nextProps, nextState)
```
- `this.props（这次传入）` 与 `nextProps（马上要传入的--更新之前）` 以及 `this.state（当前组件本次）` 与`nextState（当前组件下次--更新之前）` 进行比较

- React 可能会将 shouldComponentUpdate 视为提示而不是严格的指令，并且，当返回 false 时，仍可能导致组件重新渲染。

图谱：https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

官网解释：https://react.docschina.org/docs/react-component.html#shouldcomponentupdate



### forceUpdate

forceUpdate 可以简单的理解为 this.setState({})，只不过这个setState 是不调用自己的“shouldComponentUpdate”声明周期的。


如果 render() 方法从 this.props 或者 this.state 之外的地方读取数据，你需要通过调用 forceUpdate() 告诉 React 什么时候需要再次运行 render()。如果直接改变了 this.state，也需要调用 forceUpdate()。

``` js
class A extends React.Component{
	
	handleClick = () => {
		this.forceUpdate()
		this.forceUpdate()
		this.forceUpdate()
		this.forceUpdate()
	}
	
	shouldComponentUpdate() {
		return false
	}
	
	render() {
		return (
			<div onClick={this.handleClick}>
				<Son/> // 一个组件
			</div>
		)
	}
}
```

1. forceUpdate在批量与否的表现上，和setState是一样的。在React有控制权的函数里，是批量的。

2. forceUpdate只会强制本身组件的更新，即不调用“shouldComponentUpdate”直接更新，对于子孙后代组件还是要调用自己的“shouldComponentUpdate”来决定的